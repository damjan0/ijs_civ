'''''
Note: clustering was done by manual values read from the graph and generated by different points that those used in points.csv

no_hits.txt created by:
generateData3DLongevity.py
3DLongevity.py
'''''


import csv
import math
import numpy as np
import statistics

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

def getColour(z):
    #is it red?
    if(z>=redStart):
        return 4
    #is it orange
    elif(z>=orangeStart)and(z<redStart):
        return 3
    #is it light blu
    elif(z>=lightBluStart)and(z<orangeStart):
        return 2
    #is it darker blu
    elif(z>=darkBluStart)and(z<lightBluStart):
        return 1
    #if it is 0 aka no no.hits or very little
    elif(z<darkBluStart):
        return 0

'''''
## Changeable Parameters
'''''

minL = 2
maxL = 10       # range of maxL AKA which maxL did we use to generate data

minN = -13      #range of N
maxN = 20

numHorSec = 48  # on how many parts is Lmax devided
noBins = 50   # on how many parts is N devided


#graph limits - colours - no_hits
redStart = 2374
orangeStart = 1729
lightBluStart = 1111
darkBluStart = 2
#those no. corespond to fixed no_hits_1.txt .. always change regarding to how the graph looks like

'''''
checkpoint za točke pri no_hits_1

redStart = 2374
orangeStart = 1729
lightBluStart = 1111
darkBluStart = 2
'''''

'''''
## Load our DATASET from .csv
'''''

fileName = 'points4.csv'

x_train = []    #the whole vector

print("Loading data...")
with open(fileName) as csv_file:
    csv_reader = csv.reader(csv_file, delimiter=';')
    line_count = 0
    for row in csv_reader:
            vector = []  # empty 8D vector to store all parameters from one line
            for i in range(0,9):    #vključi vse parametre
                parameter = row[i]
                vector.append(float(parameter))
            x_train.append(vector)
            # y_train.append(math.log(float(row[0])))  #N
            #x_1 = x_train[:,1]  #take second column of x_train
            line_count += 1

print(f'Processed {line_count} lines.')

x_train = np.array(x_train)

'''''
## Load no_hits data to an array
'''''

fileName = 'no_hits.txt'

no_hitsArray = []
with open(fileName) as f:
    for item in f:
        no_hitsArray.append([int(i) for i in item.split()])
#print (len(no_hitsArray[0]))
#print(no_hitsArray[4][20])   #3492

'''''
## Finding new homes for our points -- there are noBins*numHorSec possible new homes to put our points each new home has a Z value
'''''
print("Clustering data...")

maxL_jumping = (maxL-minL)/(numHorSec-1)
N_jumping = (maxN-minN)/(noBins-1)          #N changes for N_jumping to get to the new bin

#Empty clusters
C0= [] #0 no. hits
C1= []
C2= []
C3= []
C4= []

for i in range(0,line_count):       #go through every line of our points:

    currentN = math.log10(x_train[i,0])
    curremtMaxL = math.log10(x_train[i, 8])

    whereisN = int((currentN-minN)/N_jumping)
    whereisMaxL = int((curremtMaxL - minL) / maxL_jumping)

    '''''
    print(x_train[i, 8])
    print(curremtMaxL)
    print(maxL_jumping)
    print((curremtMaxL-minL)/maxL_jumping)
    print(whereisMaxL)
    print(" ")
'''''

    currentNo_hits = no_hitsArray[whereisMaxL][whereisN]        #look at the table where we are located
    '''''
    print(str(currentN) + " " + str(curremtMaxL))
    print(str(whereisN) + " " + str(whereisMaxL))
    print(currentNo_hits)
    #print(" ")
'''''

    whichColour = getColour(currentNo_hits)         #which colour is this point
    '''''
    print(whichColour)
    print(" ")
'''''

    #Put it in the right cluster group
    if whichColour==1:
        C1.append(x_train[i])
    elif whichColour==2:
        C2.append(x_train[i])
    elif whichColour==3:
        C3.append(x_train[i])
    elif whichColour==4:
        C4.append(x_train[i])
    elif whichColour==0:
        C0.append(x_train[i])
    else:
        print("Error with data input")

C0 = np.array(C0)
C1 = np.array(C1)   #blue points
C2 = np.array(C2)
C3 = np.array(C3)
C4 = np.array(C4)   #red points

C0_len = len(C0)
C1_len = len(C1)
C2_len = len(C2)
C3_len = len(C3)
C4_len = len(C4)

print("No. of points in Cluster 0: " + str(C0_len))
print("No. of points in Cluster 1: " + str(C1_len))
print("No. of points in Cluster 2: " + str(C2_len))
print("No. of points in Cluster 3: " + str(C3_len))
print("No. of points in Cluster 4: " + str(C4_len))

'''''
## Calculating mean value and standard deviation for every parameter in every cluster
'''''
print("Calculating Mean and Std values...")

def MeanValue(lst): #calculates mean value
    return np.mean(lst)
    #return sum(lst) / len(lst)
def StdValue(lst):  #calculates std value
    return np.std(lst)

'''''
print(" ")
print(C1)
print(" ")
print(C1[:, [4]])
print(" ")
print(MeanValue(C1[:, [4]]))
'''''
#Save all means and stds into a txt file
fileName = 'MeansAndStds.txt'

file = open(fileName, 'w')
file.write("Cluster 0:"+'\n'+"No. of points in the cluster: "+ str(C0_len)+'\n')
for i in range(0,9):
    file.write("\tParameter " + str(i) + ":\t\tMean: " + str(MeanValue(C0[:, [i]])) + "\t\tStd: "+ str(StdValue(C0[:, [i]])) +'\n')
file.write("Cluster 1:"+'\n'+"No. of points in the cluster: "+ str(C1_len)+'\n')
for i in range(0,9):
    file.write("\tParameter " + str(i) + ":\t\tMean: " + str(MeanValue(C1[:, [i]])) + "\t\tStd: "+ str(StdValue(C1[:, [i]])) +'\n')
file.write('\n'+"Cluster 2:"+'\n'+"No. of points in the cluster: "+ str(C2_len)+'\n')
for i in range(0,9):
    file.write("\tParameter " + str(i) + ":\t\tMean: " + str(MeanValue(C2[:, [i]])) + "\t\tStd: "+ str(StdValue(C2[:, [i]])) +'\n')
file.write('\n'+"Cluster 3:"+'\n'+"No. of points in the cluster: "+ str(C3_len)+'\n')
for i in range(0,9):
    file.write("\tParameter " + str(i) + ":\t\tMean: " + str(MeanValue(C3[:, [i]])) + "\t\tStd: "+ str(StdValue(C3[:, [i]])) +'\n')
file.write('\n'+"Cluster 4:"+'\n'+"No. of points in the cluster: "+ str(C4_len)+'\n')
for i in range(0,9):
    file.write("\tParameter " + str(i) + ":\t\tMean: " + str(MeanValue(C4[:, [i]])) + "\t\tStd: "+ str(StdValue(C4[:, [i]])) +'\n')
file.write('\n\n' + "No. of all points: " + str(line_count))
file.close()

'''''
## Boxplots
'''''
print("Dealing with boxplots...")

for i in range(0,9):
    #Dataset of our data - colloms are clusters rows are all values of decided variable. if no data -- NaN
    l0 = C0[:, i]
    l1 = C1[:, i]
    l2 = C2[:, i]
    l3 = C3[:, i]
    l4 = C4[:, i]
    s0 = pd.Series(l0, name='C0')
    s1 = pd.Series(l1, name='C1')
    s2 = pd.Series(l2, name='C2')
    s3 = pd.Series(l3, name='C3')
    s4 = pd.Series(l4, name='C4')
    df = pd.concat([s0,s1,s2,s3,s4], axis=1)

    meanlineprops = dict(linestyle='--', linewidth=2, color='black')    #for a custom mean line

    #draw boxplot for each one
    plt.figure(figsize=(19.2, 10.8))
    sns.boxplot(data=df, orient='horizontal', notch=True, showfliers=False, meanprops=meanlineprops, showmeans=True, meanline=True)       #showfilters=points/outliers shown or not
    #sns.swarmplot(data=df, orient='horizontal', color='0.15')
    plt.title("Variable " + str(i),fontsize=13)
    filename = "Boxplot for variable " + str(i) + ".png"
    plt.savefig(filename, dpi=100)


print("Done!")